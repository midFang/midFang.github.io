<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>源码分析 on midFang&#39;s Blog</title>
    <link>https://midFang.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
    <description>Recent content in 源码分析 on midFang&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 28 Jan 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://midFang.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>OkHttp 源码分析及网络优化</title>
      <link>https://midFang.github.io/okhttp-source-code-analysis/</link>
      <pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/okhttp-source-code-analysis/</guid>
      <description>&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;OKHttp 是作为 Android 开发人员使用最多的网络库之一， 接下来从最基础的使用来介绍 OkHttp 源码里面是如何工作的。&lt;/p&gt;

&lt;p&gt;首先需要添加OkHttp的依赖&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;implementation &amp;#39;com.squareup.okhttp3:okhttp:3.5.0&amp;#39; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Android 事件分发的冲突解决方案</title>
      <link>https://midFang.github.io/android-motionevent-sliding-conflict/</link>
      <pubDate>Sun, 06 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/android-motionevent-sliding-conflict/</guid>
      <description>&lt;p&gt;阅读本文前，需要对事件分发机制所有了解，建议先阅读  &lt;a href=&#34;https://www.midfang.com/android-motionevent-soruce-code-analysis/&#34;&gt;Android 事件分发机制源码流程分析&lt;/a&gt;，但是解决这个问题之前，首先我们要知道，滑动冲突是怎么来的，为什么会存在滑动冲突呢 ？&lt;/p&gt;

&lt;p&gt;其实在 Android 中，只要是在界面中内外两层 View 可以同时滑动的时候，这个时候，就会产生滑动冲突了，或者可以理解在同一方向一个 View 上只能响应一组事件序列。当然了，部分情况下，会看到同时滑动的情况，可能是通过特殊的方式，将自己的事件序列传递给其他 View 上面了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 事件分发机制源码流程分析</title>
      <link>https://midFang.github.io/android-motionevent-soruce-code-analysis/</link>
      <pubDate>Wed, 02 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/android-motionevent-soruce-code-analysis/</guid>
      <description>&lt;p&gt;假设我们的 Activity 中的布局是这样的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/checkFang/img/master/20201129231947.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于8.0以下出现Only fullscreen opaque activities can request orientation问题的解决方案</title>
      <link>https://midFang.github.io/bug-only-fullscreen-opaque-activities-can-request-orientation/</link>
      <pubDate>Sat, 04 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/bug-only-fullscreen-opaque-activities-can-request-orientation/</guid>
      <description>前言 不得不说 Google 的适配是真的烦。真的是一不小心各种坑，市面上的 Android 版本也很多，各种各样的屏幕也很多。最近做的项目在自己手上测试的都还行，直接丢给</description>
    </item>
    
    <item>
      <title>Android源码之单例设计模式</title>
      <link>https://midFang.github.io/android-source-code-design-patterns/</link>
      <pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/android-source-code-design-patterns/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;单例设计模式可以说是我们在开发中最常用的一个设计模式了, 单利设计模式的核心思想也就是: 在整个应用的生命周期内, 只有一个对象实例的存在&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;layoutinflater-单例分析&#34;&gt;LayoutInflater 单例分析&lt;/h3&gt;

&lt;p&gt;在 Activity View 加载一个布局的时候, 通常是这样做的&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ArrayList源码分析</title>
      <link>https://midFang.github.io/arraylist-source-code-analysis/</link>
      <pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/arraylist-source-code-analysis/</guid>
      <description>开篇之前, 想想下面几个问题的答案是什么? 有的时候我们看源码也是, 并不是说一味盲目的直接跑到源码中去看, 我们带着这几个问题去阅读源码, 反而会轻</description>
    </item>
    
    <item>
      <title>EventBus 源码分析</title>
      <link>https://midFang.github.io/eventbus-source-code-analysis/</link>
      <pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/eventbus-source-code-analysis/</guid>
      <description>大致流程 EventBus 是一种用于 Android 的事件发布-订阅总线, 是一个可以实现组件间通信的一个第三方框架, 使用起来非常的简单, 一共也就是 4 个步骤, 注册订阅, 发送</description>
    </item>
    
    <item>
      <title>HashMap源码分析</title>
      <link>https://midFang.github.io/hashmap-source-code-analysis/</link>
      <pubDate>Mon, 30 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/hashmap-source-code-analysis/</guid>
      <description>HashMap 可以说是我们在开发中经常使用的到, 在 Java 的数据结构基础里，HashMap 无疑是一个非常重要的数据结构 现在看看源码里面的方法具体都干了一下什么</description>
    </item>
    
    <item>
      <title>Handler 源码分析</title>
      <link>https://midFang.github.io/android-handler-source-code-analysis/</link>
      <pubDate>Sat, 28 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/android-handler-source-code-analysis/</guid>
      <description>Handler 主要讲的就是 Android 中的消息机制, 其实讲到 Handler 就少不了几个重要的对象, 也就是 Looper , ThreadLocal , MessageQueue 首先看看是如何使用的吧, 我们就简单的从以下入手, Handler 应该也是做</description>
    </item>
    
  </channel>
</rss>