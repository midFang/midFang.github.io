<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Jane - A super concise theme for Hugo</title>
    <link>https://midFang.github.io/post/</link>
    <description>Recent content in Posts on Jane - A super concise theme for Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 15 Sep 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://midFang.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Kotlin 中的异常处理</title>
      <link>https://midFang.github.io/post/kotlin-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link>
      <pubDate>Tue, 15 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/post/kotlin-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid>
      <description>Java 中的异常处理 日常开发中难免会遇到对异常的处理，我们先来看一段按照 Java 的方式进行的异常处理： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 RetrofitUtil.getInstance().callAppData(call, object : NetListener { override fun onSuccess(message:</description>
    </item>
    
    <item>
      <title>Kotlin 中的高阶函数</title>
      <link>https://midFang.github.io/post/kotlin-%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/post/kotlin-%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</guid>
      <description>定义 如果一个函数接受另外一个函数作为参数，或者返回值的类型是另外一个函数，那么该函数称为高阶函数 函数类型的定义如下 1 (String, Int) -&amp;gt; Unit 定义一个函数类型</description>
    </item>
    
    <item>
      <title>Kotlin 中的密封类</title>
      <link>https://midFang.github.io/post/kotlin-%E4%B8%AD%E7%9A%84%E5%AF%86%E5%B0%81%E7%B1%BB/</link>
      <pubDate>Sun, 30 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/post/kotlin-%E4%B8%AD%E7%9A%84%E5%AF%86%E5%B0%81%E7%B1%BB/</guid>
      <description>密封类 密封类用来表示受限的类继承结构：当一个值为有限几种的类型, 而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合 也</description>
    </item>
    
    <item>
      <title>kotlin 中的运算符重载</title>
      <link>https://midFang.github.io/post/kotlin-%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/post/kotlin-%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid>
      <description>简介 运算符重载是 Kotlin 中的提供的一个比较有趣的语法糖，我们知道，在 Java 中有许多语言内置的运算符关键字，比如 + - * / % ++ &amp;ndash; 。而 Kotlin 中允许我们将这些所有</description>
    </item>
    
    <item>
      <title>Android 中的进程间通信简单使用</title>
      <link>https://midFang.github.io/post/android-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/post/android-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
      <description>Binder 是什么 首先在 Android 中， Binder 是一个类，实现了 IBinder 接口， 是实现跨进程通信 （IPC）的一种方式 为什么需要跨进程通信 因为在 Android 中一个应用相当于一个进程，而一</description>
    </item>
    
    <item>
      <title>WindowManager.LayoutParams 参数详解</title>
      <link>https://midFang.github.io/post/window.layoutparams/</link>
      <pubDate>Sat, 01 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/post/window.layoutparams/</guid>
      <description>WindowManager.LayoutParams 是 WindowManager 接口的嵌套类；继承于 ViewGroup.LayoutParams 。它的内容十分丰富。其实WindowManager.Java的主要内容就是由这个类定义构成。下面来分析一下这个类</description>
    </item>
    
    <item>
      <title>Git 管理 .gitignore file 文件的使用</title>
      <link>https://midFang.github.io/post/git-%E7%AE%A1%E7%90%86-.gitignore-file-%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 05 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/post/git-%E7%AE%A1%E7%90%86-.gitignore-file-%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>Git 忽略文件的原则 忽略操作系统自动生成的文件，比如缩略图等 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，</description>
    </item>
    
    <item>
      <title>《Google工作法》读书笔记</title>
      <link>https://midFang.github.io/post/google%E5%B7%A5%E4%BD%9C%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 05 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/post/google%E5%B7%A5%E4%BD%9C%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>一次结束，避免过度推迟 避免过度推迟只会浪费更多人的时间， 在一场会议之前，需要考虑会议的目标，明确会议的目的，最终要会议要取得的结果才是真正的</description>
    </item>
    
    <item>
      <title>关于8.0以下出现Only fullscreen opaque activities can request orientation问题的解决方案</title>
      <link>https://midFang.github.io/post/%E5%85%B3%E4%BA%8E8.0%E4%BB%A5%E4%B8%8B%E5%87%BA%E7%8E%B0only-fullscreen-opaque-activities-can-request-orientation%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Sat, 04 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/post/%E5%85%B3%E4%BA%8E8.0%E4%BB%A5%E4%B8%8B%E5%87%BA%E7%8E%B0only-fullscreen-opaque-activities-can-request-orientation%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>前言 不得不说 Google 的适配是真的烦。真的是一不小心各种坑，市面上的 Android 版本也很多，各种各样的屏幕也很多。最近做的项目在自己手上测试的都还行，直接丢给</description>
    </item>
    
    <item>
      <title>Java 动态代理</title>
      <link>https://midFang.github.io/post/7.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link>
      <pubDate>Fri, 10 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://midFang.github.io/post/7.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid>
      <description>动态代理和静态代理一般在设计模式中的定义为代理设计模式 定义： 为其他对象提供一种代理以控制对这个对象的访问 使用场景： 当无法或者不想直接访问某个</description>
    </item>
    
  </channel>
</rss>